[{"index":2,"topic":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。","example":"输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\n输出：7 -\u003e 0 -\u003e 8\n原因：342 + 465 \u003d 807","explanations":[{"index":1,"explanation":"链表，其中ListNode为：\n\npublic static class ListNode {\n   int val;\n   ListNode next;\n   ListNode(int x) {\n       val \u003d x;\n   }\n}\n","timeComplexity":"max(m,n)","spaceComplexity":"max(m,x)","code":"public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode pre \u003d new ListNode(0);\n    ListNode cur \u003d pre;\n    int carry \u003d 0;\n    while (l1 !\u003d null || l2 !\u003d null) {\n        int x \u003d l1 \u003d\u003d null ? 0 : l1.val;\n        int y \u003d l2 \u003d\u003d null ? 0 : l2.val;\n        int sum \u003d x + y + carry;\n\n        carry \u003d sum / 10;\n        sum \u003d sum % 10;\n        cur.next \u003d new ListNode(sum);\n\n        cur \u003d cur.next;\n        if (l1 !\u003d null)\n            l1 \u003d l1.next;\n        if (l2 !\u003d null)\n            l2 \u003d l2.next;\n    }\n    if (carry \u003d\u003d 1) {\n        cur.next \u003d new ListNode(carry);\n    }\n    return pre.next;\n}"}]},{"index":1,"topic":"给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。","example":"给定 nums \u003d [2, 7, 11, 15], target \u003d 9\n因为 nums[0] + nums[1] \u003d 2 + 7 \u003d 9\n所以返回 [0, 1]","explanations":[{"index":1,"explanation":"遍历","timeComplexity":"n^2","spaceComplexity":"1","code":"public static int[] methodA(int[] nums, int target) {\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        for (int j \u003d i + 1; j \u003c nums.length; j++) {\n            if (nums[j] \u003d\u003d target - nums[i]) {\n                return new int[]{i, j};\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"},{"index":2,"explanation":"一遍哈希表 \n 在表中进行的每次查找只花费 O(1) 的时间","timeComplexity":"n","spaceComplexity":"n","code":"public static int[] methodB(int[] nums, int target) {\n    Map\u003cInteger, Integer\u003e map \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        int complement \u003d target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"}]}]