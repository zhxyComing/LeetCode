[{"index":2,"topic":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。","example":"输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\n输出：7 -\u003e 0 -\u003e 8\n原因：342 + 465 \u003d 807","explanations":[{"index":1,"explanation":"链表，其中ListNode为：\n\npublic static class ListNode {\n   int val;\n   ListNode next;\n   ListNode(int x) {\n       val \u003d x;\n   }\n}\nm、n 表示链表长度。\n","timeComplexity":"max(m,n)","spaceComplexity":"max(m,x)","code":"public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode pre \u003d new ListNode(0);\n    ListNode cur \u003d pre;\n    int carry \u003d 0;\n    while (l1 !\u003d null || l2 !\u003d null) {\n        int x \u003d l1 \u003d\u003d null ? 0 : l1.val;\n        int y \u003d l2 \u003d\u003d null ? 0 : l2.val;\n        int sum \u003d x + y + carry;\n\n        carry \u003d sum / 10;\n        sum \u003d sum % 10;\n        cur.next \u003d new ListNode(sum);\n\n        cur \u003d cur.next;\n        if (l1 !\u003d null)\n            l1 \u003d l1.next;\n        if (l2 !\u003d null)\n            l2 \u003d l2.next;\n    }\n    if (carry \u003d\u003d 1) {\n        cur.next \u003d new ListNode(carry);\n    }\n    return pre.next;\n}"}]},{"index":3,"topic":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","example":"示例 1:\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n","explanations":[{"index":1,"explanation":"滑动窗口扫描，核心是左右指针各遍历一次，右指针移动时遇到重复，则左指针移动，直到没有重复或遍历完毕为止。\n\n提示，对于 Java String：\ncharAt：时间复杂度 O(1)，源码为 value[index]； \ncontains：时间复杂度 O(n*m)；\nsubString：时间复杂度 O(n)，beginIndex 包括在内，endIndex 不包括在内；\n所以判重不能用 String，而要考虑用 Hash 集合。 \n\n∣Σ∣ 表示所用字符集的总大小，因为 Hash 集合最大存储所有出现的字符。 \n","timeComplexity":"n","spaceComplexity":"∣Σ∣","code":"public static int lengthOfLongestSubstring(String s) {\n    // 哈希集合，记录每个字符是否出现过\n    Set\u003cCharacter\u003e occ \u003d new HashSet\u003c\u003e();\n    int n \u003d s.length();\n    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n    int rk \u003d -1, ans \u003d 0;\n    for (int i \u003d 0; i \u003c n; ++i) {\n        if (i !\u003d 0) {\n            // 左指针向右移动一格，移除一个字符\n            occ.remove(s.charAt(i - 1));\n        }\n        while (rk + 1 \u003c n \u0026\u0026 !occ.contains(s.charAt(rk + 1))) {\n            // 不断地移动右指针\n            occ.add(s.charAt(rk + 1));\n            ++rk;\n        }\n        // 第 i 到 rk 个字符是一个极长的无重复字符子串\n        ans \u003d Math.max(ans, rk - i + 1);\n    }\n    return ans;\n}"}]},{"index":206,"topic":"反转一个单链表。\n其中单链表数据结构 ListNode：\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val \u003d x;\n    }\n}","example":"输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL\n输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL","explanations":[{"index":1,"explanation":"迭代法。\n在遍历列表时，将当前节点的 next 指针改为指向前一个元素。\n举例：1-\u003e2-\u003e3-\u003enull\n第1次：1-\u003enull cur\u003d2 prev\u003d1\n第2次：2-\u003e1 cur\u003d3 prev\u003d2\n第3次：3-\u003e2 cur\u003dnull prev\u003d3\n结束。","timeComplexity":"n","spaceComplexity":"1","code":"public static ListNode reverseListA(ListNode head) {\n    ListNode prev \u003d null;\n    ListNode curr \u003d head;\n    while (curr !\u003d null) {\n        ListNode nextTemp \u003d curr.next;\n        curr.next \u003d prev;\n        prev \u003d curr;\n        curr \u003d nextTemp;\n    }\n    return prev;\n}"},{"index":2,"explanation":"递归法。\n举例：1-\u003e2-3-\u003enull\n先一直往下递归，直到head\u003d3 return 3\n第1次：node\u003d2 node.next\u003d3 3-\u003e2 2-\u003enull \n第2次：node\u003d1 node.next\u003d2 2-\u003e1 1-\u003enull\n结束。\n提示：\nnode.next\u003dnull 应当理解为 node 的下一位指向 null，\n而不应该理解为 node 的下一位的 node 的指向为 null，因为 next 代表的才是本 node 的下一位指向，\n即假如原 a.next\u003db（a 下一位指向 b），则 a.next\u003dc 表示的是 a 下一位转而指向 c，而不是 a 的原下一位 b 指向 c！\n同理，node.next.next \u003d node 可以理解为：nodeA 的下一位 nodeB 的指向为 nodeA。","timeComplexity":"n","spaceComplexity":"n","code":"public ListNode reverseListB(ListNode head) {\n    if (head \u003d\u003d null || head.next \u003d\u003d null) return head;\n    ListNode p \u003d reverseListB(head.next);\n    head.next.next \u003d head;\n    head.next \u003d null;\n    return p;\n}"}]},{"index":1,"topic":"给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。","example":"给定 nums \u003d [2, 7, 11, 15], target \u003d 9\n因为 nums[0] + nums[1] \u003d 2 + 7 \u003d 9\n所以返回 [0, 1]","explanations":[{"index":1,"explanation":"遍历","timeComplexity":"n^2","spaceComplexity":"1","code":"public static int[] methodA(int[] nums, int target) {\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        for (int j \u003d i + 1; j \u003c nums.length; j++) {\n            if (nums[j] \u003d\u003d target - nums[i]) {\n                return new int[]{i, j};\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"},{"index":2,"explanation":"一遍哈希表 \n 在表中进行的每次查找只花费 O(1) 的时间","timeComplexity":"n","spaceComplexity":"n","code":"public static int[] methodB(int[] nums, int target) {\n    Map\u003cInteger, Integer\u003e map \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        int complement \u003d target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"}]},{"index":4,"topic":"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n中位数求法：\n20、21、23、23、25、29、32、33，中位数为 24；\n0、20、 20、 20、 30，中位数为 20。\n俩个数组的中位数即数组合并后的中位数，但解题不一定要合并。","example":"示例 1:\nnums1 \u003d [1, 3]\nnums2 \u003d [2]\n则中位数是 2.0\n示例 2:\nnums1 \u003d [1, 2]\nnums2 \u003d [3, 4]\n则中位数是 (2 + 3)/2 \u003d 2.5","explanations":[{"index":1,"explanation":"暴力合并解法","timeComplexity":"m+n","spaceComplexity":"m+n","code":"public static double findMedianSortedArraysA(int[] nums1, int[] nums2) {\n    int[] nums;\n    int m \u003d nums1.length;\n    int n \u003d nums2.length;\n    nums \u003d new int[m + n];\n    if (m \u003d\u003d 0) {\n        if (n % 2 \u003d\u003d 0) {\n            return (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;\n        } else {\n            return nums2[n / 2];\n        }\n    }\n    if (n \u003d\u003d 0) {\n        if (m % 2 \u003d\u003d 0) {\n            return (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;\n        } else {\n            return nums1[m / 2];\n        }\n    }\n    int count \u003d 0;\n    int i \u003d 0, j \u003d 0;\n    while (count !\u003d (m + n)) {\n        if (i \u003d\u003d m) {\n            while (j !\u003d n) {\n                nums[count++] \u003d nums2[j++];\n            }\n            break;\n        }\n        if (j \u003d\u003d n) {\n            while (i !\u003d m) {\n                nums[count++] \u003d nums1[i++];\n            }\n            break;\n        }\n        if (nums1[i] \u003c nums2[j]) {\n            nums[count++] \u003d nums1[i++];\n        } else {\n            nums[count++] \u003d nums2[j++];\n        }\n    }\n    if (count % 2 \u003d\u003d 0) {\n        return (nums[count / 2 - 1] + nums[count / 2]) / 2.0;\n    } else {\n        return nums[count / 2];\n    }\n}"},{"index":2,"explanation":"扫描法，比直接合并数组的空间复杂度要低。\n不满足题目要求，但是思路很好值得一看。","timeComplexity":"m+n","spaceComplexity":"1","code":"public static double findMedianSortedArraysB(int[] nums1, int[] nums2) {\n    int m \u003d nums1.length;\n    int n \u003d nums2.length;\n    int len \u003d m + n;\n    int left \u003d -1, right \u003d -1;\n    int aStart \u003d 0, bStart \u003d 0;\n    for (int i \u003d 0; i \u003c\u003d len / 2; i++) {\n        left \u003d right;\n        if (aStart \u003c m \u0026\u0026 (bStart \u003e\u003d n || nums1[aStart] \u003c nums2[bStart])) {\n            right \u003d nums1[aStart++];\n        } else {\n            right \u003d nums2[bStart++];\n        }\n    }\n    if ((len \u0026 1) \u003d\u003d 0) {\n        return (left + right) / 2.0;\n    } else {\n        return right;\n    }\n}"},{"index":3,"explanation":"待补充，先学习基础排序算法与基础数据结构！","timeComplexity":"","spaceComplexity":"","code":"public static double findMedianSortedArraysC(int[] nums1, int[] nums2) {\n\n    return 0;\n}"},{"index":4,"explanation":"占位！","timeComplexity":"","spaceComplexity":"","code":"public static double findMedianSortedArraysD(int[] nums1, int[] nums2) {\n\n    return 0;\n}"}]},{"index":7,"topic":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n注意:\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。","example":"示例 1:\n输入: 123\n输出: 321\n示例 2:\n输入: -123\n输出: -321\n示例 3:\n输入: 120\n输出: 21","explanations":[{"index":1,"explanation":"弹出和推入数字 \u0026 溢出前进行检查 \n反转方式虽然简单但很有启发，值得看！","timeComplexity":"log(x)","spaceComplexity":"1","code":"public static int reverse(int x) {\n    int rev \u003d 0;\n    while (x !\u003d 0) {\n        int pop \u003d x % 10;\n        x /\u003d 10;\n        if (rev \u003e Integer.MAX_VALUE / 10 || (rev \u003d\u003d Integer.MAX_VALUE / 10 \u0026\u0026 pop \u003e 7))\n            return 0;\n        if (rev \u003c Integer.MIN_VALUE / 10 || (rev \u003d\u003d Integer.MIN_VALUE / 10 \u0026\u0026 pop \u003c -8))\n            return 0;\n        rev \u003d rev * 10 + pop;\n    }\n    return rev;\n}"}]}]