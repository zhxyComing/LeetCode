[{"index":2,"topic":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。","example":"输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\n输出：7 -\u003e 0 -\u003e 8\n原因：342 + 465 \u003d 807","explanations":[{"index":1,"explanation":"链表，其中ListNode为：\n\npublic static class ListNode {\n   int val;\n   ListNode next;\n   ListNode(int x) {\n       val \u003d x;\n   }\n}\nm、n 表示链表长度。\n","timeComplexity":"max(m,n)","spaceComplexity":"max(m,x)","code":"public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode pre \u003d new ListNode(0);\n    ListNode cur \u003d pre;\n    int carry \u003d 0;\n    while (l1 !\u003d null || l2 !\u003d null) {\n        int x \u003d l1 \u003d\u003d null ? 0 : l1.val;\n        int y \u003d l2 \u003d\u003d null ? 0 : l2.val;\n        int sum \u003d x + y + carry;\n\n        carry \u003d sum / 10;\n        sum \u003d sum % 10;\n        cur.next \u003d new ListNode(sum);\n\n        cur \u003d cur.next;\n        if (l1 !\u003d null)\n            l1 \u003d l1.next;\n        if (l2 !\u003d null)\n            l2 \u003d l2.next;\n    }\n    if (carry \u003d\u003d 1) {\n        cur.next \u003d new ListNode(carry);\n    }\n    return pre.next;\n}"}]},{"index":3,"topic":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","example":"示例 1:\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n","explanations":[{"index":1,"explanation":"滑动窗口扫描，核心是左右指针各遍历一次，右指针移动时遇到重复，则左指针移动，直到没有重复或遍历完毕为止。\n\n提示，对于 Java String：\ncharAt：时间复杂度 O(1)，源码为 value[index]； \ncontains：时间复杂度 O(n*m)；\nsubString：时间复杂度 O(n)，beginIndex 包括在内，endIndex 不包括在内；\n所以判重不能用 String，而要考虑用 Hash 集合。 \n\n∣Σ∣ 表示所用字符集的总大小，因为 Hash 集合最大存储所有出现的字符。 \n","timeComplexity":"n","spaceComplexity":"∣Σ∣","code":"public static int lengthOfLongestSubstring(String s) {\n    // 哈希集合，记录每个字符是否出现过\n    Set\u003cCharacter\u003e occ \u003d new HashSet\u003c\u003e();\n    int n \u003d s.length();\n    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n    int rk \u003d -1, ans \u003d 0;\n    for (int i \u003d 0; i \u003c n; ++i) {\n        if (i !\u003d 0) {\n            // 左指针向右移动一格，移除一个字符\n            occ.remove(s.charAt(i - 1));\n        }\n        while (rk + 1 \u003c n \u0026\u0026 !occ.contains(s.charAt(rk + 1))) {\n            // 不断地移动右指针\n            occ.add(s.charAt(rk + 1));\n            ++rk;\n        }\n        // 第 i 到 rk 个字符是一个极长的无重复字符子串\n        ans \u003d Math.max(ans, rk - i + 1);\n    }\n    return ans;\n}"}]},{"index":1,"topic":"给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。","example":"给定 nums \u003d [2, 7, 11, 15], target \u003d 9\n因为 nums[0] + nums[1] \u003d 2 + 7 \u003d 9\n所以返回 [0, 1]","explanations":[{"index":1,"explanation":"遍历","timeComplexity":"n^2","spaceComplexity":"1","code":"public static int[] methodA(int[] nums, int target) {\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        for (int j \u003d i + 1; j \u003c nums.length; j++) {\n            if (nums[j] \u003d\u003d target - nums[i]) {\n                return new int[]{i, j};\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"},{"index":2,"explanation":"一遍哈希表 \n 在表中进行的每次查找只花费 O(1) 的时间","timeComplexity":"n","spaceComplexity":"n","code":"public static int[] methodB(int[] nums, int target) {\n    Map\u003cInteger, Integer\u003e map \u003d new HashMap\u003c\u003e();\n    for (int i \u003d 0; i \u003c nums.length; i++) {\n        int complement \u003d target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}"}]}]